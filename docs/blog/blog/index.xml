<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cluster Optimizer – Blog</title>
    <link>/blog/blog/</link>
    <description>Recent content in Blog on Cluster Optimizer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    
	  <atom:link href="/blog/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Blog: Evaluate cluster hibernation cost savings</title>
      <link>/blog/2024/09/11/evaluate-cluster-hibernation-cost-savings/</link>
      <pubDate>Wed, 11 Sep 2024 00:00:00 +0000</pubDate>
      
      <guid>/blog/2024/09/11/evaluate-cluster-hibernation-cost-savings/</guid>
      <description>
        
        
        &lt;h2 id=&#34;cluster-hibernation-overview&#34;&gt;Cluster Hibernation Overview&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#cluster-hibernation-overview&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;One of the major challenges when using cloud-native clusters is resource underutilization, which leads to unnecessary costs. For instance, offline clusters such as development, testing, or demo environments often experience low utilization outside of working hours, yet organizations still pay for these idle resources.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cluster Hibernation&lt;/strong&gt; provides a mechanism to automatically or manually manage the suspension and resumption of clusters. By releasing and restoring nodes, it reduces resource consumption and optimizes resource utilization, ultimately leading to cost savings. For example, by configuring a hibernation strategy that shuts down clusters during off-hours (e.g., nights or weekends), companies can significantly reduce unnecessary resource usage and, consequently, operating costs. This makes Cluster Hibernation an effective cost management strategy, especially for non-production environments.&lt;/p&gt;
&lt;h2 id=&#34;cluster-hibernation-strategies&#34;&gt;Cluster Hibernation Strategies&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#cluster-hibernation-strategies&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Cluster Hibernation&lt;/strong&gt; works by gradually releasing nodes during the hibernation period while preserving the state of workloads (e.g., Deployments, Jobs) in the cluster. Upon resumption, the cluster nodes and workloads are restored to their pre-hibernation state. Clusters are typically managed through node groups (also known as node pools), which can consist of different node types such as reserved nodes (e.g., subscription-based) and on-demand nodes (e.g., pay-as-you-go or spot instances). Depending on whether a node group supports autoscaling, different hibernation strategies can be applied.&lt;/p&gt;
&lt;h3 id=&#34;non-autoscaling-node-groups&#34;&gt;Non-Autoscaling Node Groups&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#non-autoscaling-node-groups&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For non-autoscaling node groups, where the number of nodes is fixed and does not dynamically adjust to workload demand, node management must be performed manually. During hibernation, the node count is set to zero, prompting the cloud provider to gradually release the nodes in the group. Upon resumption, the node count is restored to its original value. It is important to note that setting the node count to zero does not necessarily mean all nodes will be released. Reserved nodes, for instance, are typically retained.&lt;/p&gt;
&lt;h3 id=&#34;autoscaling-node-groups&#34;&gt;Autoscaling Node Groups&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#autoscaling-node-groups&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Autoscaling node groups dynamically adjust the number of nodes based on actual workloads, optimizing resource usage. For such groups, the hibernation strategy involves modifying adjustable workloads and relying on the autoscaling strategy to downscale the nodes. For example, setting Deployment replicas to zero or pausing CronJobs triggers the autoscaling mechanism to reduce the number of active nodes.&lt;/p&gt;
&lt;h2 id=&#34;cluster-hibernation-benefit-evaluation&#34;&gt;Cluster Hibernation Benefit Evaluation&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#cluster-hibernation-benefit-evaluation&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;hibernation-savings-estimation-tool&#34;&gt;Hibernation Savings Estimation Tool&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#hibernation-savings-estimation-tool&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We provide the &lt;code&gt;cluster-hibernate-saving-estimate&lt;/code&gt; tool to help users assess potential resource savings within a cluster. This tool scans each node group within the cluster and provides an overview, including the maximum potential savings, current savings, recommended actions, and the total sum of resource requests from Deployments in the node group. Key metrics include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Max Potential Saving&lt;/strong&gt;: The maximum savings achievable by optimizing the node distribution (e.g., adjusting node types to an ideal setup).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Potential Saving&lt;/strong&gt;: The savings attainable under the current configuration of the node group.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sum of Deployment Resource Requests&lt;/strong&gt;: The total resource requests (CPU, memory) of Pods in the group’s Deployments, serving as a reference for evaluating resource usage. Higher request totals typically indicate greater potential savings in autoscaling node groups.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: The Hibernation Savings Estimation Tool can be downloaded from &lt;code&gt;https://github.com/wiseinf/cluster-hibernate-saving-estimate/tags&lt;/code&gt;. It currently supports platforms like Alibaba Cloud and AWS.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let’s explore two common scenarios to evaluate the benefits of Cluster Hibernation.&lt;/p&gt;
&lt;h4 id=&#34;scenario-1-non-autoscaling-node-group-with-reserved-nodes&#34;&gt;Scenario 1: Non-Autoscaling Node Group with Reserved Nodes&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#scenario-1-non-autoscaling-node-group-with-reserved-nodes&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;In non-autoscaling node groups containing only reserved nodes, a typical output is as follows:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;NodeGroup: cpu-ng(npa324882932487c9777eaa7f6854e4)  Total Nodes: 4  Autoscaling: false
  OnDemandNodes: 0  
  SpotNodes: 0  
  ReservedNodes: 4  cpu: 32 cores, memory: 128 gib
    Node: cn-beijing.171.19.105.70(i-bp19u4ufadv9niflo1o4) NoSpot, InstanceType: ecs.g7ne.2xlarge, ChargeType: PrePaid
    Node: cn-beijing.171.19.105.74(i-bp19u4ufadv9niflo1o3) NoSpot, InstanceType: ecs.g7ne.2xlarge, ChargeType: PrePaid
    Node: cn-beijing.171.19.105.71(i-bp19u4ufadv9niflo1o5) NoSpot, InstanceType: ecs.g7ne.2xlarge, ChargeType: PrePaid
    Node: cn-beijing.171.19.105.251(i-bp161b0ldoqt1k771t5e) NoSpot, InstanceType: ecs.g7ne.2xlarge, ChargeType: PrePaid
  Max Potential Saving: CPU: 14125.71 core hours; Memory: 56502.86 gib hours
  Potential Saving: No saving, no spot or on demand nodes
  Recommendation: adjust some reserved nodes to on-demand or spot nodes based on its usage
  Sum of Deployment Resource Requests: CPU 8.63 cores, Memory 18.68 gibs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This node group consists of four reserved nodes, with a total of 32 CPU cores and 128 GiB of memory. Assuming the node group hibernates every evening (9 PM) and resumes in the morning (8 AM) from Monday to Friday, the potential savings are calculated as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Maximum CPU savings: &lt;strong&gt;14,125.71 core hours&lt;/strong&gt;&lt;br&gt;
Calculation: &lt;code&gt;32 (CPU cores) * 720 (hours/month) * 103 (hibernation hours/week) / 168 (hours/week)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Similar calculations apply to memory savings.&lt;/p&gt;
&lt;p&gt;In this case, there are no potential savings, as all nodes are reserved and setting the node count to zero does not release any of them. To achieve savings, some reserved nodes should be converted to on-demand nodes.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: When adjusting node types, consider the cost differences between reserved and on-demand nodes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;scenario-2-autoscaling-node-group-with-on-demand-nodes&#34;&gt;Scenario 2: Autoscaling Node Group with On-Demand Nodes&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#scenario-2-autoscaling-node-group-with-on-demand-nodes&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;NodeGroup: as-cpu-ng(np151adb107448039712d3a24f0d50a)  Total Nodes: 12  Autoscaling: true
  OnDemandNodes: 6  cpu: 192 cores, memory: 384 gib
    Node: cn-beijing.171.18.106.158(i-bp6f7txtyecxuauzgk6m) NoSpot, InstanceType: ecs.hfc7.8xlarge, ChargeType: PrePaid
    Node: cn-beijing.171.18.106.76(i-bp6f7txtyecxuauzgk6o) NoSpot, InstanceType: ecs.hfc7.8xlarge, ChargeType: PrePaid
  ...
  Max Potential Saving: CPU: 98880 core hours; Memory: 197760 gib hours
  Potential Saving: CPU: 84754.29 core hours; Memory: 169508.57 gib hours
  Recommendation: no recommendation
  Sum of Deployment Resource Requests: CPU 224.00 cores, Memory 448.00 gibs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For this autoscaling node group, maximum potential CPU savings are calculated as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Maximum CPU savings: &lt;strong&gt;98,880 core hours&lt;/strong&gt;&lt;br&gt;
Calculation: &lt;code&gt;224 (total CPU cores) * 720 (hours/month) * 103 (hibernation hours/week) / 168 (hours/week)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Similarly, the potential CPU savings amount to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Potential CPU savings: &lt;strong&gt;84,754.29 core hours&lt;/strong&gt;&lt;br&gt;
Calculation: &lt;code&gt;192 (active CPU cores) * 720 (hours/month) * 103 (hibernation hours/week) / 168 (hours/week)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The potential CPU savings are lower than the maximum savings, as the current configuration does not fully optimize node utilization. Adjusting reserved nodes to on-demand could help achieve maximum savings.&lt;/p&gt;
&lt;h2 id=&#34;challenges--solutions&#34;&gt;Challenges &amp;amp; Solutions&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#challenges--solutions&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;workload-state-preservation-and-restoration&#34;&gt;Workload State Preservation and Restoration&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#workload-state-preservation-and-restoration&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Cluster Hibernation involves suspending and restoring workloads, and users often worry about incomplete restoration leading to workload unavailability. Since Cluster Hibernation mainly operates by adjusting node groups (releasing and restoring nodes), any issue arising during hibernation will likely affect production as well. In cloud-native environments, applications should be resilient. The best approach is to identify and address the root cause of workload unavailability to ensure the application can withstand node failures. This improves both production stability and resilience during hibernation.&lt;/p&gt;
&lt;h3 id=&#34;maintaining-workload-availability-during-hibernation&#34;&gt;Maintaining Workload Availability During Hibernation&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#maintaining-workload-availability-during-hibernation&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To keep workloads running during hibernation, the following conditions must be met:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The workload should be schedulable on an autoscaling node group.&lt;/li&gt;
&lt;li&gt;The workload should include the label &lt;code&gt;wiseinf.com/reserved&lt;/code&gt; with a value of &lt;code&gt;true&lt;/code&gt;. The system will skip workloads with this label during hibernation adjustments. Currently, only three workload types are supported: &lt;code&gt;Deployment&lt;/code&gt;, &lt;code&gt;DaemonSet&lt;/code&gt;, and &lt;code&gt;CronJob&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#conclusion&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Cluster Hibernation is an effective cost management strategy, especially for non-production environments. The Hibernation Savings Estimation Tool enables users to quickly evaluate potential resource savings for each node pool when applying hibernation strategies. By reviewing common scenarios (autoscaling and non-autoscaling node groups), users can better assess their cost-saving opportunities and adjust settings to reduce resource costs.&lt;/p&gt;
&lt;h2 id=&#34;about-the-cluster-optimizer-platform&#34;&gt;About the &lt;strong&gt;Cluster Optimizer&lt;/strong&gt; Platform&lt;a class=&#34;td-heading-self-link&#34; href=&#34;#about-the-cluster-optimizer-platform&#34; aria-label=&#34;Heading self-link&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The &lt;strong&gt;Cluster Optimizer&lt;/strong&gt; platform, developed by &lt;strong&gt;WiseInf&lt;/strong&gt;, is a comprehensive cloud-native optimization solution designed to help organizations reduce costs and enhance operational efficiency. By analyzing cloud resources, application performance, user behavior, and cloud vendor data, it identifies cost-saving opportunities and delivers tailored recommendations. The platform also automates the optimization process, minimizing manual errors and streamlining operations to ensure greater efficiency.&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
